/*! (c) Andrea Giammarchi - ISC */
try{if(!self.customElements.get("f-d")){class u extends HTMLLIElement{}self.customElements.define("f-d",u,{extends:"li"}),new u}}catch(d){const{keys:f}=Object,h=e=>{const t=f(e),n=[],{length:r}=t;for(let o=0;o<r;o++)n[o]=e[t[o]],delete e[t[o]];return()=>{for(let o=0;o<r;o++)e[t[o]]=n[o]}},g=!0,p=!1,b="querySelectorAll",m=(e,t=document,n=MutationObserver,r=["*"])=>{const o=(t,n,r,s,l,a)=>{for(const c of t)(a||b in c)&&(l?r.has(c)||(r.add(c),s.delete(c),e(c,l)):s.has(c)||(s.add(c),r.delete(c),e(c,l)),a||o(c[b](n),n,r,s,l,g))},s=new n((e=>{if(r.length){const t=r.join(","),n=new Set,s=new Set;for(const{addedNodes:r,removedNodes:l}of e)o(l,t,n,s,p,p),o(r,t,n,s,g,p)}})),{observe:l}=s;return(s.observe=e=>l.call(s,e,{subtree:g,childList:g}))(t),s},y="querySelectorAll",{document:w,Element:v,MutationObserver:S,Set:E,WeakMap:H}=self,A=e=>y in e,{filter:T}=[];var e=e=>{const t=new H,n=(n,r)=>{let s;if(r)for(let l,a=(e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector)(n),c=0,{length:i}=o;c<i;c++)a.call(n,l=o[c])&&(t.has(n)||t.set(n,new E),s=t.get(n),s.has(l)||(s.add(l),e.handle(n,r,l)));else t.has(n)&&(s=t.get(n),t.delete(n),s.forEach((t=>{e.handle(n,r,t)})))},r=(e,t=!0)=>{for(let r=0,{length:o}=e;r<o;r++)n(e[r],t)},{query:o}=e,s=e.root||w,l=m(n,s,S,o),{attachShadow:a}=v.prototype;return a&&(v.prototype.attachShadow=function(e){const t=a.call(this,e);return l.observe(t),t}),o.length&&r(s[y](o)),{drop:e=>{for(let n=0,{length:r}=e;n<r;n++)t.delete(e[n])},flush:()=>{const e=l.takeRecords();for(let t=0,{length:n}=e;t<n;t++)r(T.call(e[t].removedNodes,A),!1),r(T.call(e[t].addedNodes,A),!0)},observer:l,parse:r}};const{customElements:M,document:L,Element:O,MutationObserver:x,Object:C,Promise:q,Map:N,Set:P,WeakMap:k,Reflect:D}=self,{createElement:$}=L,{define:I,get:R,upgrade:j}=M,{construct:F}=D||{construct(e){return e.call(this)}},{defineProperty:V,getOwnPropertyNames:U,setPrototypeOf:W}=C,_=new k,B=new P,z=new N,G=new N,J=new N,K=new N,Q=[],X=[],Y=e=>K.get(e)||R.call(M,e),Z=(e,t,n)=>{const r=J.get(n);if(t&&!r.isPrototypeOf(e)){const t=h(e);se=W(e,r);try{new r.constructor}finally{se=null,t()}}const o=(t?"":"dis")+"connectedCallback";o in r&&e[o]()},{parse:ee}=e({query:X,handle:Z}),{parse:te}=e({query:Q,handle(e,n){_.has(e)&&(n?B.add(e):B.delete(e),X.length&&t.call(X,e))}}),{attachShadow:ne}=O.prototype;ne&&(O.prototype.attachShadow=function(e){const t=ne.call(this,e);return _.set(this,t),t});const re=e=>{if(!G.has(e)){let t,n=new q((e=>{t=e}));G.set(e,{$:n,_:t})}return G.get(e).$},oe=((e,t)=>{const n=e=>{for(let t=0,{length:n}=e;t<n;t++)r(e[t])},r=({target:e,attributeName:t,oldValue:n})=>{e.attributeChangedCallback(t,n,e.getAttribute(t))};return(o,s)=>{const{observedAttributes:l}=o.constructor;return l&&e(s).then((()=>{new t(n).observe(o,{attributes:!0,attributeOldValue:!0,attributeFilter:l});for(let e=0,{length:t}=l;e<t;e++)o.hasAttribute(l[e])&&r({target:o,attributeName:l[e],oldValue:null})})),o}})(re,x);let se=null;function t(e){const t=_.get(e);ee(t.querySelectorAll(this),e.isConnected)}U(self).filter((e=>/^HTML.*Element$/.test(e))).forEach((e=>{const t=self[e];function n(){const{constructor:e}=this;if(!z.has(e))throw new TypeError("Illegal constructor");const{is:n,tag:r}=z.get(e);if(n){if(se)return oe(se,n);const t=$.call(L,r);return t.setAttribute("is",n),oe(W(t,e.prototype),n)}return F.call(this,t,[],e)}W(n,t),V(n.prototype=t.prototype,"constructor",{value:n}),V(self,e,{value:n})})),V(L,"createElement",{configurable:!0,value(e,t){const n=t&&t.is;if(n){const t=K.get(n);if(t&&z.get(t).tag===e)return new t}const r=$.call(L,e);return n&&r.setAttribute("is",n),r}}),V(M,"get",{configurable:!0,value:Y}),V(M,"whenDefined",{configurable:!0,value:re}),V(M,"upgrade",{configurable:!0,value(e){const t=e.getAttribute("is");if(t){const n=K.get(t);if(n)return void oe(W(e,n.prototype),t)}j.call(M,e)}}),V(M,"define",{configurable:!0,value(e,n,r){if(Y(e))throw new Error(`'${e}' has already been defined as a custom element`);let o;const s=r&&r.extends;z.set(n,s?{is:e,tag:s}:{is:"",tag:e}),s?(o=`${s}[is="${e}"]`,J.set(o,n.prototype),K.set(e,n),X.push(o)):(I.apply(M,arguments),Q.push(o=e)),re(e).then((()=>{s?(ee(L.querySelectorAll(o)),B.forEach(t,[o])):te(L.querySelectorAll(o))})),G.get(e)._(n)}})}const n={A:"Anchor",Caption:"TableCaption",DL:"DList",Dir:"Directory",Img:"Image",OL:"OList",P:"Paragraph",TR:"TableRow",UL:"UList",Article:"",Aside:"",Footer:"",Header:"",Main:"",Nav:"",Element:"",H1:"Heading",H2:"Heading",H3:"Heading",H4:"Heading",H5:"Heading",H6:"Heading",TD:"TableCell",TH:"TableCell",TBody:"TableSection",TFoot:"TableSection",THead:"TableSection"},r=Symbol("extends"),{customElements:o}=self,{define:s}=o,l=new Map,a=(e,t)=>{const n=[e,t];return r in t&&n.push({extends:t[r].toLowerCase()}),s.apply(o,n),l.set(t,e),t},c=(e,t)=>t?a(e,t):t=>a(e,t),i=new Proxy(new Map,{get(e,t){if(!e.has(t)){const s=self[(o=t,"HTML"+(o in n?n[o]:o)+"Element")];e.set(t,"Element"===t?class extends s{}:class extends s{static get[r](){return t}constructor(){super().hasAttribute("is")||this.setAttribute("is",l.get(this.constructor))}})}var o;return e.get(t)}});export{r as EXTENDS,i as HTML,c as define};