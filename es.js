/*! (c) Andrea Giammarchi - ISC */
try{if(!self.customElements.get("f-d")){class i extends HTMLLIElement{}self.customElements.define("f-d",i,{extends:"li"}),new i}}catch(d){const{keys:h}=Object,f=e=>{const t=h(e),r=[],{length:n}=t;for(let s=0;s<n;s++)r[s]=e[t[s]],delete e[t[s]];return()=>{for(let s=0;s<n;s++)e[t[s]]=r[s]}},g=!0,p=!1,b="querySelectorAll";function e(e){this.observe(e,{subtree:g,childList:g})}const y=(t,r,n)=>{const s=(e,r,n,l,o)=>{for(let a=0,{length:c}=e;a<c;a++){const c=e[a];(o||b in c)&&(l?r.has(c)||(r.add(c),n.delete(c),t(c,l)):n.has(c)||(n.add(c),r.delete(c),t(c,l)),o||s(c[b]("*"),r,n,l,g))}},l=new(n||MutationObserver)((e=>{for(let t=new Set,r=new Set,n=0,{length:l}=e;n<l;n++){const{addedNodes:l,removedNodes:o}=e[n];s(o,t,r,p,p),s(l,t,r,g,p)}}));return l.add=e,l.add(r||document),l},w="querySelectorAll",{document:m,Element:v,MutationObserver:E,Set:S,WeakMap:A}=self,M=e=>w in e,{filter:q}=[];var t=e=>{const t=new A,r=(r,n)=>{let l;if(n)for(let o,a=(e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector)(r),c=0,{length:u}=s;c<u;c++)a.call(r,o=s[c])&&(t.has(r)||t.set(r,new S),l=t.get(r),l.has(o)||(l.add(o),e.handle(r,n,o)));else t.has(r)&&(l=t.get(r),t.delete(r),l.forEach((t=>{e.handle(r,n,t)})))},n=(e,t=!0)=>{for(let n=0,{length:s}=e;n<s;n++)r(e[n],t)},{query:s}=e,l=e.root||m,o=y(r,l,E),{attachShadow:a}=v.prototype;return a&&(v.prototype.attachShadow=function(e){const t=a.call(this,e);return o.add(t),t}),s.length&&n(l[w](s)),{drop:e=>{for(let r=0,{length:n}=e;r<n;r++)t.delete(e[r])},flush:()=>{const e=o.takeRecords();for(let t=0,{length:r}=e;t<r;t++)n(q.call(e[t].removedNodes,M),!1),n(q.call(e[t].addedNodes,M),!0)},observer:o,parse:n}};const{customElements:x,document:O,Element:N,MutationObserver:k,Object:L,Promise:P,Map:$,Set:C,WeakMap:T,Reflect:V}=self,{attachShadow:j}=N.prototype,{createElement:H}=O,{define:I,get:R,upgrade:W}=x,{construct:_}=V||{construct(e){return e.call(this)}},{defineProperty:D,getOwnPropertyNames:F,setPrototypeOf:z}=L,B=new T,G=new C,J=new $,K=new $,Q=new $,U=new $,X=[],Y=[],Z=e=>U.get(e)||R.call(x,e),ee=(e,t,r)=>{const n=Q.get(r);if(t&&!n.isPrototypeOf(e)){const t=f(e);le=z(e,n);try{new n.constructor}finally{le=null,t()}}const s=(t?"":"dis")+"connectedCallback";s in n&&e[s]()},{parse:te}=t({query:Y,handle:ee}),{parse:re}=t({query:X,handle(e,t){B.has(e)&&(t?G.add(e):G.delete(e),Y.length&&r.call(Y,e))}}),ne=e=>{if(!K.has(e)){let t,r=new P((e=>{t=e}));K.set(e,{$:r,_:t})}return K.get(e).$},se=((e,t)=>{const r=e=>{for(let t=0,{length:r}=e;t<r;t++)n(e[t])},n=({target:e,attributeName:t,oldValue:r})=>{e.attributeChangedCallback(t,r,e.getAttribute(t))};return(s,l)=>{const{observedAttributes:o}=s.constructor;return o&&e(l).then((()=>{new t(r).observe(s,{attributes:!0,attributeOldValue:!0,attributeFilter:o});for(let e=0,{length:t}=o;e<t;e++)s.hasAttribute(o[e])&&n({target:s,attributeName:o[e],oldValue:null})})),s}})(ne,k);let le=null;function r(e){const t=B.get(e);te(t.querySelectorAll(this),e.isConnected)}F(self).filter((e=>/^HTML.*Element$/.test(e))).forEach((e=>{const t=self[e];function r(){const{constructor:e}=this;if(!J.has(e))throw new TypeError("Illegal constructor");const{is:r,tag:n}=J.get(e);if(r){if(le)return se(le,r);const t=H.call(O,n);return t.setAttribute("is",r),se(z(t,e.prototype),r)}return _.call(this,t,[],e)}z(r,t),D(r.prototype=t.prototype,"constructor",{value:r}),D(self,e,{value:r})})),D(O,"createElement",{configurable:!0,value(e,t){const r=t&&t.is;if(r){const t=U.get(r);if(t&&J.get(t).tag===e)return new t}const n=H.call(O,e);return r&&n.setAttribute("is",r),n}}),j&&(N.prototype.attachShadow=function(e){const t=j.call(this,e);return B.set(this,t),t}),D(x,"get",{configurable:!0,value:Z}),D(x,"whenDefined",{configurable:!0,value:ne}),D(x,"upgrade",{configurable:!0,value(e){const t=e.getAttribute("is");if(t){const r=U.get(t);if(r)return void se(z(e,r.prototype),t)}W.call(x,e)}}),D(x,"define",{configurable:!0,value(e,t,n){if(Z(e))throw new Error(`'${e}' has already been defined as a custom element`);let s;const l=n&&n.extends;J.set(t,l?{is:e,tag:l}:{is:"",tag:e}),l?(s=`${l}[is="${e}"]`,Q.set(s,t.prototype),U.set(e,t),Y.push(s)):(I.apply(x,arguments),X.push(s=e)),ne(e).then((()=>{l?(te(O.querySelectorAll(s)),G.forEach(r,[s])):re(O.querySelectorAll(s))})),K.get(e)._(t)}})}const n=Symbol("extends"),{customElements:s}=self,{define:l}=s,o=new Map,a=(e,t)=>{const r=[e,t];return n in t&&r.push({extends:t[n].toLowerCase()}),l.apply(s,r),o.set(t,e),t},c=(e,t)=>t?a(e,t):t=>a(e,t),u=new Proxy(new Map,{get(e,t){if(!e.has(t)){const r=self[qualify(t)];e.set(t,t===ELEMENT?class extends r{}:class extends r{static get[n](){return t}constructor(){super().hasAttribute("is")||this.setAttribute("is",o.get(this.constructor))}})}return e.get(t)}});export{n as EXTENDS,u as HTML,c as define};