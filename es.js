/*! (c) Andrea Giammarchi - ISC */
try{if(!self.customElements.get("f-d")){class e extends HTMLLIElement{}self.customElements.define("f-d",e,{extends:"li"}),new e}}catch(r){const{keys:s}=Object,l=e=>{const t=s(e),n=[],{length:r}=t;for(let s=0;s<r;s++)n[s]=e[t[s]],delete e[t[s]];return()=>{for(let s=0;s<r;s++)e[t[s]]=n[s]}},o=!0,a=!1,c="querySelectorAll";function e(e){this.observe(e,{subtree:o,childList:o})}const i=(t,n,r)=>{const s=(e,n,r,l,a)=>{for(let i=0,{length:u}=e;i<u;i++){const u=e[i];(a||c in u)&&(l?n.has(u)||(n.add(u),r.delete(u),t(u,l)):r.has(u)||(r.add(u),n.delete(u),t(u,l)),a||s(u[c]("*"),n,r,l,o))}},l=new(r||MutationObserver)((e=>{for(let t=new Set,n=new Set,r=0,{length:l}=e;r<l;r++){const{addedNodes:l,removedNodes:c}=e[r];s(c,t,n,a,a),s(l,t,n,o,a)}}));return l.add=e,l.add(n||document),l},u="querySelectorAll",{document:d,Element:h,MutationObserver:f,Set:g,WeakMap:p}=self,b=e=>u in e,{filter:m}=[];var t=e=>{const t=new p,n=(n,r)=>{let l;if(r)for(let o,a=(e=>e.matches||e.webkitMatchesSelector||e.msMatchesSelector)(n),c=0,{length:i}=s;c<i;c++)a.call(n,o=s[c])&&(t.has(n)||t.set(n,new g),l=t.get(n),l.has(o)||(l.add(o),e.handle(n,r,o)));else t.has(n)&&(l=t.get(n),t.delete(n),l.forEach((t=>{e.handle(n,r,t)})))},r=(e,t=!0)=>{for(let r=0,{length:s}=e;r<s;r++)n(e[r],t)},{query:s}=e,l=e.root||d,o=i(n,l,f),{attachShadow:a}=h.prototype;return a&&(h.prototype.attachShadow=function(e){const t=a.call(this,e);return o.add(t),t}),s.length&&r(l[u](s)),{drop:e=>{for(let n=0,{length:r}=e;n<r;n++)t.delete(e[n])},flush:()=>{const e=o.takeRecords();for(let t=0,{length:n}=e;t<n;t++)r(m.call(e[t].removedNodes,b),!1),r(m.call(e[t].addedNodes,b),!0)},observer:o,parse:r}};const{customElements:w,document:y,Element:v,MutationObserver:E,Object:A,Promise:H,Map:S,Set:M,WeakMap:L,Reflect:O}=self,{attachShadow:T}=v.prototype,{createElement:x}=y,{define:C,get:q,upgrade:N}=w,{construct:P}=O||{construct(e){return e.call(this)}},{defineProperty:k,getOwnPropertyNames:D,setPrototypeOf:$}=A,I=new L,R=new M,V=new S,j=new S,F=new S,U=new S,W=[],_=[],z=e=>U.get(e)||q.call(w,e),B=(e,t,n)=>{const r=F.get(n);if(t&&!r.isPrototypeOf(e)){const t=l(e);X=$(e,r);try{new r.constructor}finally{X=null,t()}}const s=(t?"":"dis")+"connectedCallback";s in r&&e[s]()},{parse:G}=t({query:_,handle:B}),{parse:J}=t({query:W,handle(e,t){I.has(e)&&(t?R.add(e):R.delete(e),_.length&&n.call(_,e))}}),K=e=>{if(!j.has(e)){let t,n=new H((e=>{t=e}));j.set(e,{$:n,_:t})}return j.get(e).$},Q=((e,t)=>{const n=e=>{for(let t=0,{length:n}=e;t<n;t++)r(e[t])},r=({target:e,attributeName:t,oldValue:n})=>{e.attributeChangedCallback(t,n,e.getAttribute(t))};return(s,l)=>{const{observedAttributes:o}=s.constructor;return o&&e(l).then((()=>{new t(n).observe(s,{attributes:!0,attributeOldValue:!0,attributeFilter:o});for(let e=0,{length:t}=o;e<t;e++)s.hasAttribute(o[e])&&r({target:s,attributeName:o[e],oldValue:null})})),s}})(K,E);let X=null;function n(e){const t=I.get(e);G(t.querySelectorAll(this),e.isConnected)}D(self).filter((e=>/^HTML.*Element$/.test(e))).forEach((e=>{const t=self[e];function n(){const{constructor:e}=this;if(!V.has(e))throw new TypeError("Illegal constructor");const{is:n,tag:r}=V.get(e);if(n){if(X)return Q(X,n);const t=x.call(y,r);return t.setAttribute("is",n),Q($(t,e.prototype),n)}return P.call(this,t,[],e)}$(n,t),k(n.prototype=t.prototype,"constructor",{value:n}),k(self,e,{value:n})})),k(y,"createElement",{configurable:!0,value(e,t){const n=t&&t.is;if(n){const t=U.get(n);if(t&&V.get(t).tag===e)return new t}const r=x.call(y,e);return n&&r.setAttribute("is",n),r}}),T&&(v.prototype.attachShadow=function(e){const t=T.call(this,e);return I.set(this,t),t}),k(w,"get",{configurable:!0,value:z}),k(w,"whenDefined",{configurable:!0,value:K}),k(w,"upgrade",{configurable:!0,value(e){const t=e.getAttribute("is");if(t){const n=U.get(t);if(n)return void Q($(e,n.prototype),t)}N.call(w,e)}}),k(w,"define",{configurable:!0,value(e,t,r){if(z(e))throw new Error(`'${e}' has already been defined as a custom element`);let s;const l=r&&r.extends;V.set(t,l?{is:e,tag:l}:{is:"",tag:e}),l?(s=`${l}[is="${e}"]`,F.set(s,t.prototype),U.set(e,t),_.push(s)):(C.apply(w,arguments),W.push(s=e)),K(e).then((()=>{l?(G(y.querySelectorAll(s)),R.forEach(n,[s])):J(y.querySelectorAll(s))})),j.get(e)._(t)}})}const r=Symbol("extends"),{customElements:s}=self,{define:l}=s,o=new Map,a=(e,t)=>{const n=[e,t];return r in t&&n.push({extends:t[r].toLowerCase()}),l.apply(s,n),o.set(t,e),t},c=(e,t)=>t?a(e,t):t=>a(e,t),i={A:"Anchor",Caption:"TableCaption",DL:"DList",Dir:"Directory",Img:"Image",OL:"OList",P:"Paragraph",TR:"TableRow",UL:"UList",Article:"",Aside:"",Footer:"",Header:"",Main:"",Nav:"",Element:"",H1:"Heading",H2:"Heading",H3:"Heading",H4:"Heading",H5:"Heading",H6:"Heading",TD:"TableCell",TH:"TableCell"},u=new Proxy(new Map,{get(e,t){if(!e.has(t)){const n=self["HTML"+(t in i?i[t]:t)+"Element"];e.set(t,"Element"===t?class extends n{}:class extends n{static get[r](){return t}constructor(){super().hasAttribute("is")||this.setAttribute("is",o.get(this.constructor))}})}return e.get(t)}});export{r as EXTENDS,u as HTML,c as define};